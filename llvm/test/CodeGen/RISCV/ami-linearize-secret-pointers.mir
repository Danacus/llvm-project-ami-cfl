# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -march=riscv32 -disable-branch-fold -run-pass=ami-linearize %s -o - 2>&1 | FileCheck %s

--- |
  ; ModuleID = 'challenge.opt.ll'
  source_filename = "challenge.c"
  target datalayout = "e-m:e-p:32:32-i64:64-n32-S128"
  target triple = "riscv32-unknown-unknown"
  
  @v = internal global i32 0, align 4
  
  ; Function Attrs: nofree norecurse nounwind
  define dso_local secret(2) ptr @challenge(ptr noundef returned secret(2) %p1, ptr noundef secret(1) %p2) local_unnamed_addr #0 {
  entry:
    %cmp.not = icmp eq ptr %p1, null
    br i1 %cmp.not, label %if.end3, label %if.then
  
  if.then:                                          ; preds = %entry
    %0 = load i32, ptr %p1, align 4, !tbaa !4
    %cmp1.not = icmp eq i32 %0, 0
    br i1 %cmp1.not, label %if.end3, label %if.then2
  
  if.then2:                                         ; preds = %if.then
    store i32 7, ptr %p1, align 4, !tbaa !4
    br label %if.end3
  
  if.end3:                                          ; preds = %if.then2, %if.then, %entry
    %cmp4 = icmp ugt ptr %p1, %p2
    br i1 %cmp4, label %if.then5, label %if.end6
  
  if.then5:                                         ; preds = %if.end3
    store volatile i32 19, ptr @v, align 4, !tbaa !4
    br label %if.end6
  
  if.end6:                                          ; preds = %if.then5, %if.end3
    %1 = load i32, ptr %p2, align 4, !tbaa !4
    %cmp7 = icmp eq i32 %1, 0
    br i1 %cmp7, label %if.then8, label %if.end9
  
  if.then8:                                         ; preds = %if.end6
    store i32 42, ptr %p2, align 4, !tbaa !4
    br label %if.end9
  
  if.end9:                                          ; preds = %if.then8, %if.end6
    ret ptr %p1
  }
  
  attributes #0 = { nofree norecurse nounwind "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-features"="+32bit,+m,+relax,-save-restore" }
  
  !llvm.module.flags = !{!0, !1, !2}
  !llvm.ident = !{!3}
  
  !0 = !{i32 1, !"wchar_size", i32 4}
  !1 = !{i32 1, !"target-abi", !"ilp32"}
  !2 = !{i32 1, !"SmallDataLimit", i32 8}
  !3 = !{!"clang version 16.0.0 (git@gitlab.kuleuven.be:u0126303/llvm-project.git 2c581acdbc29e77ff25bf4f922fdb7de24ae44c2)"}
  !4 = !{!5, !5, i64 0}
  !5 = !{!"int", !6, i64 0}
  !6 = !{!"omnipotent char", !7, i64 0}
  !7 = !{!"Simple C/C++ TBAA"}

...
---
name:            challenge
alignment:       4
tracksRegLiveness: true
tracksDebugUserValues: true
liveins:
  - { reg: '$x10' }
  - { reg: '$x11' }
frameInfo:
  maxAlignment:    1
  maxCallFrameSize: 0
machineFunctionInfo:
  varArgsFrameIndex: 0
  varArgsSaveSize: 0
body:             |  
  bb.0.entry:
    successors: %bb.3(0x30000000), %bb.1(0x50000000)
    liveins: $x10, $x11

  ; CHECK:        SECRET renamable $x10, 2
  ; CHECK-NEXT:   BEQ renamable $x10, $x0, %bb.3
    SECRET renamable $x10, 2
    BEQ renamable $x10, $x0, %bb.3

  bb.1.if.then:
    successors: %bb.3(0x30000000), %bb.2(0x50000000)
    liveins: $x10, $x11

  ; CHECK:        renamable $x12 = LW renamable $x10, 0 :: (load (s32) from %ir.p1, !tbaa !4)
  ; CHECK-NEXT:   ABEQ killed renamable $x12, $x0, %bb.3
    renamable $x12 = LW renamable $x10, 0 :: (load (s32) from %ir.p1, !tbaa !4)
    BEQ killed renamable $x12, $x0, %bb.3

  bb.2.if.then2:
    successors: %bb.3(0x80000000)
    liveins: $x10, $x11

  ; CHECK:        renamable $x12 = PADDI $x0, 7
  ; CHECK-NEXT:   $x12 = GLW renamable $x10, 0
  ; CHECK-NEXT:   SW killed renamable $x12, renamable $x10, 0 :: (store (s32) into %ir.p1, !tbaa !4)
    renamable $x12 = ADDI $x0, 7
    SW killed renamable $x12, renamable $x10, 0 :: (store (s32) into %ir.p1, !tbaa !4)

  bb.3.if.end3:
    successors: %bb.4(0x40000000), %bb.5(0x40000000)
    liveins: $x10, $x11

  ; CHECK:        SECRET renamable $x11, 1
  ; CHECK-NEXT:   ABGEU renamable $x11, renamable $x10, %bb.5
    SECRET renamable $x11, 1
    BGEU renamable $x11, renamable $x10, %bb.5

  bb.4.if.then5:
    successors: %bb.5(0x80000000)
    liveins: $x10, $x11

  ; CHECK:        renamable $x12 = PLUI target-flags(riscv-hi) @v
  ; CHECK-NEXT:   renamable $x13 = PADDI $x0, 19
  ; CHECK-NEXT:   $x13 = GLW killed renamable $x12, target-flags(riscv-lo) @v
  ; CHECK-NEXT:   SW killed renamable $x13, killed renamable $x12, target-flags(riscv-lo) @v :: (volatile store (s32) into @v, !tbaa !4)
    renamable $x12 = LUI target-flags(riscv-hi) @v
    renamable $x13 = ADDI $x0, 19
    SW killed renamable $x13, killed renamable $x12, target-flags(riscv-lo) @v :: (volatile store (s32) into @v, !tbaa !4)

  bb.5.if.end6:
    successors: %bb.7(0x30000000), %bb.6(0x50000000)
    liveins: $x10, $x11

  ; CHECK:        renamable $x12 = LW renamable $x11, 0 :: (load (s32) from %ir.p2, !tbaa !4)
  ; CHECK-NEXT:   BEQ killed renamable $x12, $x0, %bb.7
    renamable $x12 = LW renamable $x11, 0 :: (load (s32) from %ir.p2, !tbaa !4)
    BEQ killed renamable $x12, $x0, %bb.7

  bb.6.if.end9:
    liveins: $x10

    PseudoRET implicit $x10

  bb.7.if.then8:
    liveins: $x10, $x11

    renamable $x12 = ADDI $x0, 42
    SW killed renamable $x12, killed renamable $x11, 0 :: (store (s32) into %ir.p2, !tbaa !4)
    PseudoRET implicit $x10

...
